
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://sami-s-hajjaj.github.io/ai-labs/lab3a/">
      
      
        <link rel="prev" href="../lab2/">
      
      
        <link rel="next" href="../lab3b/">
      
      
      <link rel="icon" href="../img/favicon.ico">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.12">
    
    
      
        <title>Lab 3 (Part I): Search Algorithms (Machine Learning Onramp) - CSC3206 AI Labs</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.2afb09e1.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../stylesheets/extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#lab-3-part-i-search-algorithms-machine-learning-onramp" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="CSC3206 AI Labs" class="md-header__button md-logo" aria-label="CSC3206 AI Labs" data-md-component="logo">
      
  <img src="../img/favicon.ico" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            CSC3206 AI Labs
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Lab 3 (Part I): Search Algorithms (Machine Learning Onramp)
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href=".." class="md-tabs__link">
          
  
  
  Current

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


  

<nav class="md-nav md-nav--primary md-nav--lifted md-nav--integrated" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="CSC3206 AI Labs" class="md-nav__button md-logo" aria-label="CSC3206 AI Labs" data-md-component="logo">
      
  <img src="../img/favicon.ico" alt="logo">

    </a>
    CSC3206 AI Labs
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
    
  
  
  
    
    
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_1" checked>
        
          
          <label class="md-nav__link" for="__nav_1" id="__nav_1_label" tabindex="">
            
  
  
  <span class="md-ellipsis">
    Current
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_1_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_1">
            <span class="md-nav__icon md-icon"></span>
            Current
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Overview
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../get-start/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Getting started
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../lab1/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Lab 1 Python Refresher (MATLAB Onramp)
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../lab2/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Lab 2: Lab 2: Python - Data Handling (Statistics Onramp)
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    Lab 3 (Part I): Search Algorithms (Machine Learning Onramp)
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Lab 3 (Part I): Search Algorithms (Machine Learning Onramp)
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#breadth-first-search-bfs-algorithm" class="md-nav__link">
    <span class="md-ellipsis">
      Breadth-First Search (BFS) algorithm
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Breadth-First Search (BFS) algorithm">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#elements-of-search-algorithm" class="md-nav__link">
    <span class="md-ellipsis">
      Elements of Search Algorithm
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1-state-representation" class="md-nav__link">
    <span class="md-ellipsis">
      1. State Representation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-the-state-space" class="md-nav__link">
    <span class="md-ellipsis">
      2. The State space
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-the-transition-model" class="md-nav__link">
    <span class="md-ellipsis">
      3. The Transition model
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#using-python-classes-objects-object-oriented-programming" class="md-nav__link">
    <span class="md-ellipsis">
      Using Python Classes &amp; Objects (Object Oriented Programming)
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#the-breadth-first-search-bfs-algorithm" class="md-nav__link">
    <span class="md-ellipsis">
      The Breadth-First Search (BFS) algorithm
    </span>
  </a>
  
    <nav class="md-nav" aria-label="The Breadth-First Search (BFS) algorithm">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#running-the-algorithm" class="md-nav__link">
    <span class="md-ellipsis">
      Running the algorithm
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#preparation-for-next-week-part-ii" class="md-nav__link">
    <span class="md-ellipsis">
      Preparation for next week (Part II)
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../lab3b/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Lab 3 (Part II): Search Algorithms (Machine Learning Onramp)
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../lab4/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Lab 4: Linear Regression (Regression Methods with ML)
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../lab5/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Lab 5: k Nearest Neighbours (KNN) (Classification Methods with ML)
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../lab6/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Lab 6: Decision Tree
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../lab7/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Lab 7: Clustering (Cluster Analysis with ML)
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="lab-3-part-i-search-algorithms-machine-learning-onramp">Lab 3 (Part I): Search Algorithms (Machine Learning Onramp)</h1>
<h2 id="breadth-first-search-bfs-algorithm">Breadth-First Search (BFS) algorithm</h2>
<p>After completing this lab, you will be able to implement the <strong>Breadth-First Search (BFS)</strong> search algorithm in Python.</p>
<p>The first search problem we are focusing on is Nick’s route-finding problem in Romania, starting in Arad to reach Bucharest. The road map of Romania, which is the state space of the problem is given as follows:</p>
<div>
<div id="romania">
<svg viewBox="0 0 950 500">

<path d="M 75 125 L 100 75" stroke="black" />
<text :x="(75+100)/2" :y="(125+75)/2" text-anchor="end">75</text>
<path d="M 100 75 L 125 25" stroke="black" />
<text :x="(100+125)/2" :y="(75+25)/2" text-anchor="end">71</text>
<path d="M 125 25 L 265 175" stroke="black" />
<text :x="(125+265)/2" :y="(25+175)/2-10" text-anchor="start">151</text>
<path d="M 265 175 L 75 125" stroke="black" />
<text :x="(265+75)/2" :y="(175+125)/2+15" text-anchor="end">140</text>
<path d="M 75 125 L 85 280" stroke="black" />
<text :x="(75+85)/2-5" :y="(125+280)/2" text-anchor="end">118</text>
<path d="M 85 280 L 185 335" stroke="black" />
<text :x="(85+185)/2+5" :y="(280+335)/2-5" text-anchor="start">111</text>
<path d="M 185 335 L 190 390" stroke="black" />
<text :x="(185+190)/2+10" :y="(335+390)/2" text-anchor="start">70</text>
<path d="M 190 390 L 185 450" stroke="black" />
<text :x="(190+185)/2+10" :y="(390+450)/2" text-anchor="start">75</text>
<path d="M 185 450 L 350 465" stroke="black" />
<text :x="(185+350)/2" :y="(450+465)/2-10" text-anchor="end">120</text>
<path d="M 350 465 L 320 230" stroke="black" />
<text :x="(350+320)/2-10" :y="(465+230)/2" text-anchor="end">146</text>
<path d="M 320 230 L 265 175" stroke="black" />
<text :x="(320+265)/2+5" :y="(230+175)/2" text-anchor="start">80</text>
<path d="M 265 175 L 425 175" stroke="black" />
<text :x="(265+425)/2" :y="(175+175)/2-5" text-anchor="middle">99</text>
<path d="M 320 230 L 475 310" stroke="black" />
<text :x="(320+475)/2" :y="(230+310)/2-5" text-anchor="start">97</text>
<path d="M 475 310 L 350 465" stroke="black" />
<text :x="(475+350)/2-5" :y="(310+465)/2-5" text-anchor="end">138</text>
<path d="M 475 310 L 640 390" stroke="black" />
<text :x="(475+640)/2-10" :y="(310+390)/2+10" text-anchor="end">101</text>
<path d="M 425 175 L 640 390" stroke="black" />
<text :x="(425+640)/2+5" :y="(175+390)/2-5" text-anchor="start">211</text>
<path d="M 640 390 L 575 485" stroke="black" />
<text :x="(640+575)/2-5" :y="(390+485)/2" text-anchor="end">90</text>
<path d="M 640 390 L 745 340 " stroke="black" />
<text :x="(640+745)/2-5" :y="(390+340)/2" text-anchor="end">85</text>
<path d="M 745 340 L 875 340" stroke="black" />
<text :x="(745+875)/2" :y="(340+340)/2+15" text-anchor="middle">98</text>
<path d="M 875 340 L 935 440" stroke="black" />
<text :x="(875+935)/2-10" :y="(340+440)/2+5" text-anchor="end">86</text>
<path d="M 745 340 L 850 225" stroke="black" />
<text :x="(745+850)/2-5" :y="(340+225)/2-5" text-anchor="end">142</text>
<path d="M 850 225 L 760 120" stroke="black" />
<text :x="(850+760)/2+5" :y="(225+120)/2" text-anchor="start">92</text>
<path d="M 760 120 L 625 60" stroke="black" />
<text :x="(760+625)/2+5" :y="(120+60)/2-5" text-anchor="start">87</text>

<circle cx="75" cy="125" :r="circleradius" fill="green" />
<text x="60" y="130" text-anchor="end">Arad</text>
<circle cx="100" cy="75" :r="circleradius" fill="gray" />
<text x="85" y="75" text-anchor="end">Zerind</text>
<circle cx="125" cy="25" :r="circleradius" fill="gray" />
<text x="110" y="20" text-anchor="end">Oradea</text>
<circle cx="265" cy="175" :r="circleradius" fill="gray" />
<text x="265" y="160" text-anchor="start">Sibiu</text>
<circle cx="425" cy="175" :r="circleradius" fill="gray" />
<text x="440" y="180" text-anchor="start">Fagaras</text>
<circle cx="320" cy="230" :r="circleradius" fill="gray" />
<text x="305" y="235" text-anchor="end">Rimnicu Vilcea</text>
<circle cx="475" cy="310" :r="circleradius" fill="gray" />
<text x="460" y="320" text-anchor="end">Pitesti</text>
<circle cx="350" cy="465" :r="circleradius" fill="gray" />
<text x="340" y="480" text-anchor="end">Craiova</text>
<circle cx="185" cy="450" :r="circleradius" fill="gray" />
<text x="170" y="455" text-anchor="end">Drobeta</text>
<circle cx="190" cy="390" :r="circleradius" fill="gray" />
<text x="175" y="395" text-anchor="end">Mehadia</text>
<circle cx="185" cy="335" :r="circleradius" fill="gray" />
<text x="170" y="345" text-anchor="end">Lugoj</text>
<circle cx="85" cy="280" :r="circleradius" fill="gray" />
<text x="70" y="285" text-anchor="end">Timisoara</text>
<circle cx="640" cy="390" :r="circleradius" fill="red" />
<text x="625" y="400" text-anchor="end">Bucharest</text>
<circle cx="575" cy="485" :r="circleradius" fill="gray" />
<text x="560" y="490" text-anchor="end">Giurgiu</text>
<circle cx="745" cy="340" :r="circleradius" fill="gray" />
<text x="730" y="335" text-anchor="end">Urziceni</text>
<circle cx="875" cy="340" :r="circleradius" fill="gray" />
<text x="875" y="325" text-anchor="end">Hirsova</text>
<circle cx="935" cy="440" :r="circleradius" fill="gray" />
<text x="920" y="445" text-anchor="end">Eforie</text>
<circle cx="850" cy="225" :r="circleradius" fill="gray" />
<text x="835" y="230" text-anchor="end">Vaslui</text>
<circle cx="760" cy="120" :r="circleradius" fill="gray" />
<text x="745" y="135" text-anchor="end">Iasi</text>
<circle cx="625" cy="60" :r="circleradius" fill="gray" />
<text x="610" y="65" text-anchor="end">Neamt</text>

</svg>
</div>
<script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
<script>new Vue({ el: "#romania", data: { circleradius: 10 } });</script>
</div>

<h3 id="elements-of-search-algorithm">Elements of Search Algorithm</h3>
<p>As we discussed in the class, in order to execute a Search Algorithm, we need to define the following items: </p>
<ul>
<li>State Representation </li>
<li>The State Space </li>
<li>The Transition Model </li>
</ul>
<p>Furthermore, you will need your program to be more robust to be able to implement other Search Algorithms without drastic changes. More on that later. </p>
<h3 id="1-state-representation">1. State Representation</h3>
<p>In this problem, the only state we need to consider is the <em>location</em> of Nick. Therefore we can use the names of the cities as the state.</p>
<p>Since Nick is starting in Arad, going to Bucharest, we can define the <em>initial state</em> and <em>goal state</em> as: </p>
<div class="highlight"><pre><span></span><code><span class="n">initial_state</span> <span class="o">=</span> <span class="s2">&quot;Arad&quot;</span>
<span class="n">goal_state</span> <span class="o">=</span> <span class="s2">&quot;Bucharest&quot;</span>
</code></pre></div>
<h3 id="2-the-state-space">2. The State space</h3>
<p>The transition model provides the way to identify the child of a node in a search tree given a specific action. In this problem, we need to translate the whole state space from the geographical network into the program together with the step costs between the connected states.</p>
<p>The important information from the state space is the connections between states and the step costs between connected states. Notice that in this problem the connections are reversible. Therefore in our state space the connection from Arad to Zerind and the connection from Zerind to Arad are identical, hence only one instance of that connection is needed.</p>
<p>The most straightforward way of defining the state space is by using a nested array, in which each inner array consists of the two connected states and its cost. </p>
<p>Define a variable <code>state_space</code> to store the state space. As seen below, it is a nested list (a list containing inner lists). The following code shows the first three elements in the nested list. 
<div class="highlight"><pre><span></span><code><span class="n">state_space</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">[</span><span class="s1">&#39;Arad&#39;</span><span class="p">,</span> <span class="s1">&#39;Zerind&#39;</span><span class="p">,</span> <span class="mi">75</span><span class="p">],</span>
  <span class="p">[</span><span class="s1">&#39;Arad&#39;</span><span class="p">,</span> <span class="s1">&#39;Timisoara&#39;</span><span class="p">,</span> <span class="mi">118</span><span class="p">],</span>
  <span class="p">[</span><span class="s1">&#39;Timisoara&#39;</span><span class="p">,</span> <span class="s1">&#39;Lugoj&#39;</span><span class="p">,</span> <span class="mi">111</span><span class="p">],</span>
  <span class="o">...</span>
<span class="p">]</span>
</code></pre></div></p>
<p><strong>Task 1:</strong> Complete the list of cities and distances in the <code>state_space</code> variable </p>
<h3 id="3-the-transition-model">3. The Transition model</h3>
<p>In this problem, the transition model is defined by the action of <em>traveling</em> between connected cities. To represent this action, we can create a <em>function</em> that searches through the state space to find the children of the current node, which effectively represents the available travel options.</p>
<p>This function iterates through the <code>state_space</code> variable, checking for connections linked to the current node. Each city connected to the current node becomes a <em>child</em> of that node. We define a new function called <code>expandAndReturnChildren</code> to handle this process.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">expandAndReturnChildren</span><span class="p">(</span><span class="n">state_space</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
  <span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="ow">in</span> <span class="n">state_space</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">node</span><span class="p">:</span>
      <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="n">node</span><span class="p">:</span>
      <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">children</span>
</code></pre></div>
<p>This function explores the state_space, and returns a list of all possible children of <code>node</code>.</p>
<p><strong>Discussion:</strong> 
- how does this function actually work? read the code and see if you can understand its inner workings.
- Instead of n,m,c, why not use something more descriptive like City1, City2, Cost ?  </p>
<p><strong>Task 2:</strong> Implement <code>expandAndReturnChildren</code> in your program and test its validity</p>
<h2 id="using-python-classes-objects-object-oriented-programming">Using Python Classes &amp; Objects (Object Oriented Programming)</h2>
<p>Although we can proceed with the current code to implement BFS, it will become increasingly complex as the search deepens. To make the code more manageable and adaptable for future search algorithms, we can adopt an object-oriented approach. By defining a class to represent each "city" in the state space tree and using objects to model each city instance, we simplify the structure. This not only enhances readability but also makes the code more robust and flexible for implementing other search strategies.</p>
<p>To achieve this, we define each city as a <em>Node</em>. Each node stores key information,
- state: the name of the city itself
- parent: the name of the preceding city in the search tree. 
- children: a list cites in the branches in the search tree. </p>
<p>The Class definition also includes a method that adds children cities to the current node (more on that later)</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Node</span><span class="p">:</span>
  <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>      

  <span class="k">def</span><span class="w"> </span><span class="nf">addChildren</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">children</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>      
</code></pre></div>
<p>This structure allows us to trace the path from any node back to the initial state, enabling efficient path reconstruction once the goal is found.</p>
<div class="admonition info">
<p class="admonition-title">Class in Python</p>
<p>In Python, to define a class, the class needs to have the function <code>__init__</code> with at least one input <code>self</code>. This function is called when an object is initiated with this class. The internal variable <code>self</code> defines the properties of the object. The input arguments apart from <code>self</code> for the function <code>__init__</code> are the parameters to be passed when initiating a new object.</p>
<p>In a class, additional functions can also be defined, and these will be the methods for the object of this class. </p>
</div>
<p>With this implementation of node as a class, the <code>expandAndReturnChildren</code> function is updated to be</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">expandAndReturnChildren</span><span class="p">(</span><span class="n">state_space</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
  <span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="ow">in</span> <span class="n">state_space</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">state</span><span class="p">:</span>
      <span class="n">childnode</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
      <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">childnode</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">state</span><span class="p">:</span>
      <span class="n">childnode</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
      <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">childnode</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">children</span>
</code></pre></div>
<p><strong>Discussion:</strong> </p>
<ul>
<li>Discuss the changes to <code>expandAndReturnChildren</code> (Specfically: Objects vs. Strings) </li>
<li>in this function, we first create a <code>childenode</code> object, then in the next line we append it to <code>Children</code>, why not do that in one line? </li>
<li>what about the cost? we seem to ignore so far, <em>why?</em>. can you modify the function to capture the cost as well? (more on that later)  </li>
</ul>
<p>Think about these issues before you continue. </p>
<div class="admonition tip">
<p class="admonition-title">A Quick check</p>
<p>Your current code should look like</p>
<div class="highlight"><pre><span></span><code><span class="n">initial_state</span> <span class="o">=</span> <span class="s2">&quot;Arad&quot;</span>
<span class="n">goal_state</span> <span class="o">=</span> <span class="s2">&quot;Bucharest&quot;</span>

<span class="n">state_space</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">[</span><span class="s1">&#39;Arad&#39;</span><span class="p">,</span> <span class="s1">&#39;Zerind&#39;</span><span class="p">,</span> <span class="mi">75</span><span class="p">],</span>
  <span class="p">[</span><span class="s1">&#39;Arad&#39;</span><span class="p">,</span> <span class="s1">&#39;Timisoara&#39;</span><span class="p">,</span> <span class="mi">118</span><span class="p">],</span>
  <span class="p">[</span><span class="s1">&#39;Timisoara&#39;</span><span class="p">,</span> <span class="s1">&#39;Lugoj&#39;</span><span class="p">,</span> <span class="mi">111</span><span class="p">],</span>
  <span class="o">...</span>
<span class="p">]</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Node</span><span class="p">:</span>
  <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>      

  <span class="k">def</span><span class="w"> </span><span class="nf">addChildren</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">children</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>              

<span class="k">def</span><span class="w"> </span><span class="nf">expandAndReturnChildren</span><span class="p">(</span><span class="n">state_space</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
  <span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="ow">in</span> <span class="n">state_space</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">state</span><span class="p">:</span>
      <span class="n">childnode</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
      <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">childnode</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">state</span><span class="p">:</span>
      <span class="n">childnode</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
      <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">childnode</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">children</span>
</code></pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Separation of Problem Definition vs. Algorithm Definition.</p>
<p>By defining the key elements—namely, the initial state, goal state, state space, and transition model—<strong>before implementing the BFS algorithm</strong>, we have effectively separated the problem from the algorithm.</p>
<p>This separation offers significant advantages in programming, particularly in terms of flexibility and reusability:</p>
<ul>
<li>
<p>The initial state represents the starting point of the search—in this case, the city where the journey begins.</p>
</li>
<li>
<p>The goal state defines the destination or target that the algorithm is trying to reach.</p>
</li>
<li>
<p>The state space outlines all the possible connections between cities, including the cost of traveling from one to another. It serves as the map or environment within which the search operates.</p>
</li>
<li>
<p>The transition model defines how one can move from one state (city) to another. It governs the valid moves or actions available and is typically implemented as a function that returns the next possible states (children) from a given current state.</p>
</li>
</ul>
</div>
<h2 id="the-breadth-first-search-bfs-algorithm">The Breadth-First Search (BFS) algorithm</h2>
<p>Below is the complete code for the BFS Search Algorithm. Please review it first — we’ll then go through it step by step to understand how it works</p>
<div class="admonition tip">
<p class="admonition-title">The BFS Algorithm: The Complete Code</p>
<div class="highlight"><pre><span></span><code><span class="c1"># The BFS Search Algorithm  </span>
<span class="k">def</span><span class="w"> </span><span class="nf">bfs</span><span class="p">(</span><span class="n">state_space</span><span class="p">,</span> <span class="n">initial_state</span><span class="p">,</span> <span class="n">goal_state</span><span class="p">):</span>
    <span class="c1"># STEP 1 - Initialization</span>
    <span class="n">frontier</span>    <span class="o">=</span> <span class="p">[]</span>        <span class="c1"># the front-line, the CURRENT exploration/test node</span>
    <span class="n">explored</span>    <span class="o">=</span> <span class="p">[]</span>        <span class="c1"># list of nodes we already explored  </span>
    <span class="n">found_goal</span>  <span class="o">=</span> <span class="kc">False</span>
    <span class="n">frontier</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="n">initial_state</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>  <span class="c1"># first node in the frontier is the initial_state       </span>
    <span class="n">goal_node</span>   <span class="o">=</span> <span class="n">Node</span><span class="p">()</span>
    <span class="n">solution</span>    <span class="o">=</span> <span class="p">[]</span>    
    <span class="n">path_cost</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># STEP 2 - Search for Goal Loop  </span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">found_goal</span><span class="p">:</span>

        <span class="c1"># 2.1 Manage the Frontier &amp; Explored Lists </span>
        <span class="n">children</span> <span class="o">=</span> <span class="n">expandAndReturnChildren</span><span class="p">(</span><span class="n">state_space</span><span class="p">,</span> <span class="n">frontier</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">frontier</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">addChildren</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>
        <span class="n">explored</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frontier</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">del</span> <span class="n">frontier</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># 2.2 Goal Test</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
            <span class="c1"># first, check if node was alrady expanded or explored</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">state</span> <span class="ow">in</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">state</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">explored</span><span class="p">])</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">state</span> <span class="ow">in</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">state</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">frontier</span><span class="p">]):</span> 
                <span class="c1"># next, check if node is goal</span>
                <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">goal_state</span><span class="p">:</span>
                    <span class="n">found_goal</span> <span class="o">=</span> <span class="kc">True</span>       <span class="c1"># end algorithm </span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Goal Found!&quot;</span><span class="p">)</span>
                    <span class="n">goal_node</span> <span class="o">=</span> <span class="n">child</span>       <span class="c1"># for later processing</span>
                <span class="n">frontier</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>      <span class="c1"># to search deeper   </span>

        <span class="c1"># 2.3 Progress output  </span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Explored:&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">state</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">explored</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Frontier:&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">state</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">frontier</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Children:&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">state</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="c1"># STEP 3 Find Solution path </span>
    <span class="n">solution</span> <span class="o">=</span> <span class="p">[</span><span class="n">goal_node</span><span class="o">.</span><span class="n">state</span><span class="p">]</span>        <span class="c1"># start from goal node</span>
    <span class="n">trace_node</span> <span class="o">=</span> <span class="n">goal_node</span>              <span class="c1"># use the trace node to trace the path back to the initial node</span>

    <span class="c1"># 3.1 trace your steps and find the solution path</span>
    <span class="k">while</span> <span class="n">trace_node</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>                <span class="c1"># are you back to the initial_state ?</span>
        <span class="n">solution</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trace_node</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>     <span class="c1"># then find the parent and add it to the solution list</span>
        <span class="n">trace_node</span> <span class="o">=</span> <span class="n">trace_node</span><span class="o">.</span><span class="n">parent</span>                  <span class="c1"># set trace to parent (to go back one level, and repeat)</span>

    <span class="c1"># 3.2 determine the cose of the solution path. </span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">city1</span> <span class="o">=</span> <span class="n">solution</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">city2</span> <span class="o">=</span> <span class="n">solution</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="p">[</span><span class="n">from_city</span><span class="p">,</span> <span class="n">to_city</span><span class="p">,</span> <span class="n">cost</span><span class="p">]</span> <span class="ow">in</span> <span class="n">state_space</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">from_city</span> <span class="o">==</span> <span class="n">city1</span> <span class="ow">and</span> <span class="n">to_city</span> <span class="o">==</span> <span class="n">city2</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">from_city</span> <span class="o">==</span> <span class="n">city2</span> <span class="ow">and</span> <span class="n">to_city</span> <span class="o">==</span> <span class="n">city1</span><span class="p">):</span>
                <span class="n">path_cost</span> <span class="o">+=</span> <span class="n">cost</span>
                <span class="k">break</span>  <span class="c1"># Exit once the matching pair is found</span>

    <span class="k">return</span> <span class="n">solution</span><span class="p">,</span> <span class="n">path_cost</span>
</code></pre></div>
</div>
<p>Now, let's go step by step. As discussed in the class, the BFS algorithm revolves around the use of two key lists:</p>
<ul>
<li>
<p><strong>frontier</strong>: Nodes (cities) that are discovered but not yet explored</p>
</li>
<li>
<p><strong>explored</strong>: Nodes (cities) that have been fully examined</p>
</li>
</ul>
<p>The algorithm systematically moves nodes from the <strong>frontier</strong> to <strong>explored</strong> as it traverses the <code>state_space</code>, continuing until the <code>goal_state</code> is found. The major steps of the BFS algorithm include the following key steps:</p>
<ul>
<li>
<p><code>Initialization:</code> Set up the initial variables, including placing the starting city into the frontier.</p>
</li>
<li>
<p><code>The Search Loop:</code> This step repeatedly explores the search space by expanding nodes, testing for the goal, and updating progress.</p>
</li>
<li>
<p><code>Solution &amp; Cost:</code> Once the goal is found, this step traces the solution path back to <code>inital_stat</code>, then calculates the its cost. </p>
</li>
</ul>
<p><strong>Step 0: Function definition and inputs</strong></p>
<p>We will now implement the BFS algorithm as a Python function that takes the <code>state_space</code>, <code>initial_state</code>, and <code>goal_state</code> as arguments (inputs). </p>
<p>Additionally, the BFS funtion utilizes the <code>expandAndReturnChildren</code> function and the <code>Node</code> Class defintion and its methods.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">bfs</span><span class="p">(</span><span class="n">state_space</span><span class="p">,</span> <span class="n">initial_state</span><span class="p">,</span> <span class="n">goal_state</span><span class="p">):</span>
</code></pre></div>
<p><strong>Step 1: Initialization</strong></p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">bfs</span><span class="p">(</span><span class="n">state_space</span><span class="p">,</span> <span class="n">initial_state</span><span class="p">,</span> <span class="n">goal_state</span><span class="p">):</span>

    <span class="c1"># STEP 1 - Initialization</span>
    <span class="n">frontier</span>    <span class="o">=</span> <span class="p">[]</span>        
    <span class="n">explored</span>    <span class="o">=</span> <span class="p">[]</span>         
    <span class="n">found_goal</span>  <span class="o">=</span> <span class="kc">False</span>

    <span class="n">frontier</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="n">initial_state</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>  
    <span class="n">goal_node</span>   <span class="o">=</span> <span class="n">Node</span><span class="p">()</span>
    <span class="n">solution</span>    <span class="o">=</span> <span class="p">[]</span>    
    <span class="n">path_cost</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
<p>In this first step, we set up the key variables that drive the BFS process—defining the <code>frontier</code>, <code>explored</code>, and placing the initial state as the starting node. While some variables like <code>goal_node</code>, <code>solution</code>, and <code>path_cost</code> are prepared for later use. </p>
<p><strong>Discussion:</strong> 
- evaluate each variable definition and explain why it is needed
- why is goal_node is defined as a blank object and not a String? </p>
<div class="admonition info">
<p class="admonition-title"><code>Node(initial_state, None)</code></p>
<p>As the root node has no parent, we use <code>None</code> as the value of the parent of root node.</p>
</div>
<p><strong>Step 2: The Search Loop</strong></p>
<p>After initialization, the algorithm enters the search loop, which is the heart of BFS. In this loop, we systematically explore the nodes in the <code>frontier</code> until the goal is found. Each cycle of the loop involves three main parts:</p>
<ul>
<li>2.1 Managing the <code>frontier</code> and <code>explored</code> lists to track which nodes have been discovered and processed,</li>
<li>2.2 Performing a <strong>goal test</strong> to check whether we’ve reached the destination, and</li>
<li>2.3 Outputting the current progress to help us observe how the search unfolds step by step.</li>
</ul>
<p>We’ll now break down each of these subsection in more detail</p>
<div class="highlight"><pre><span></span><code>    <span class="c1"># STEP 2 - The Search Loop  </span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">found_goal</span><span class="p">:</span>
        <span class="c1"># 2.1 Manage the Frontier &amp; Explored Lists </span>
        <span class="n">children</span> <span class="o">=</span> <span class="n">expandAndReturnChildren</span><span class="p">(</span><span class="n">state_space</span><span class="p">,</span> <span class="n">frontier</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">frontier</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">addChildren</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>
        <span class="n">explored</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frontier</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">del</span> <span class="n">frontier</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div>
<p><strong>Discussion:</strong> 
- read each line and understand what is going on </p>
<div class="highlight"><pre><span></span><code>        <span class="c1"># 2.2 Goal Test</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
            <span class="c1"># first, check if node was alrady expanded or explored</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">state</span> <span class="ow">in</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">state</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">explored</span><span class="p">])</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">state</span> <span class="ow">in</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">state</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">frontier</span><span class="p">]):</span> 
                <span class="c1"># next, check if node is goal</span>
                <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">goal_state</span><span class="p">:</span>
                    <span class="n">found_goal</span> <span class="o">=</span> <span class="kc">True</span>       <span class="c1"># end algorithm </span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Goal Found!&quot;</span><span class="p">)</span>
                    <span class="n">goal_node</span> <span class="o">=</span> <span class="n">child</span>       <span class="c1"># for later processing</span>
                <span class="n">frontier</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>      <span class="c1"># to search deeper   </span>
</code></pre></div>
<p><strong>Discussion:</strong> 
- what happens if we dont check for redundancies?</p>
<div class="admonition info">
<p class="admonition-title">List comprehension</p>
<p>In step 2.2, we use a special Syntax; <code>[e.state for e in explored]</code> which is referred to as List Comprehension. List comprehension provides a shorter syntax to create a new list. </p>
<p>This example loops through the list variable <code>explored</code> and create a list with the values of <code>.state</code> for each element (node) in the <code>explored</code> list.</p>
<p>This one-liner is equivalent to</p>
<div class="highlight"><pre><span></span><code><span class="n">explored_nodes</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">explored</span><span class="p">:</span>
  <span class="n">explored_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="highlight"><pre><span></span><code>        <span class="c1"># 2.3 Progress output  </span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Explored:&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">state</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">explored</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Frontier:&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">state</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">frontier</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Children:&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">state</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
</code></pre></div>
<p><strong>Discussion:</strong> 
- Is this step really necessary? what value does it add to your code? </p>
<p><strong>Step 3: Solution &amp; Cost</strong></p>
<p>Now that the algorithm has identified the <code>goal_node</code>, we can trace the solution through the parent of the goal node all the way back to the root node (node with no parent). Then the function should return the solution of BFS.</p>
<div class="highlight"><pre><span></span><code>    <span class="c1"># STEP 3 Find Solution path </span>
    <span class="n">solution</span> <span class="o">=</span> <span class="p">[</span><span class="n">goal_node</span><span class="o">.</span><span class="n">state</span><span class="p">]</span>        
    <span class="n">trace_node</span> <span class="o">=</span> <span class="n">goal_node</span>              

    <span class="c1"># 3.1 trace your steps and find the solution path</span>
    <span class="k">while</span> <span class="n">trace_node</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>                
        <span class="n">solution</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trace_node</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>     
        <span class="n">trace_node</span> <span class="o">=</span> <span class="n">trace_node</span><span class="o">.</span><span class="n">parent</span>                  
</code></pre></div>
<p><strong>Discussion:</strong> 
- Read the code of each step and understand its inner workings 
- try to understand how the solution path is created in the end
- Question: what is the difference between the Solution List, and the other lists we defined earlier (such as Frontier or Explored)? </p>
<p>Next, the final step, is the determine the cost of this solution path. At this point, we finally utilize the cost element that is part of the <code>state_space</code> as we discussed early on. </p>
<div class="highlight"><pre><span></span><code>    <span class="c1"># 3.2 determine the cose of the solution path. </span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">city1</span> <span class="o">=</span> <span class="n">solution</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">city2</span> <span class="o">=</span> <span class="n">solution</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="p">[</span><span class="n">from_city</span><span class="p">,</span> <span class="n">to_city</span><span class="p">,</span> <span class="n">cost</span><span class="p">]</span> <span class="ow">in</span> <span class="n">state_space</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">from_city</span> <span class="o">==</span> <span class="n">city1</span> <span class="ow">and</span> <span class="n">to_city</span> <span class="o">==</span> <span class="n">city2</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">from_city</span> <span class="o">==</span> <span class="n">city2</span> <span class="ow">and</span> <span class="n">to_city</span> <span class="o">==</span> <span class="n">city1</span><span class="p">):</span>
                <span class="n">path_cost</span> <span class="o">+=</span> <span class="n">cost</span>
                <span class="k">break</span>   
</code></pre></div>
<p><strong>Discussion:</strong> 
- Read the code of each step and understand its inner workings 
- what is += and why is it used here ? 
- In your opinion, is this an efficient way to calculate path cost? is there a better way?</p>
<h3 id="running-the-algorithm">Running the algorithm</h3>
<p>Now we have two functions <code>expandAndReturnChildren</code> and <code>bfs</code>, alongside with the variables <code>state_space</code>, <code>initial_state</code>, and <code>goal_state</code>.</p>
<p>To run a script to execute the <code>bfs</code> function, we can have the script file structured as such:</p>
<div class="highlight"><pre><span></span><code>```python
initial_state = &#39;Arad&#39;
goal_state = &#39;Bucharest&#39;

state_space = [
  ...
]

class Node:
  ...

def expandAndReturnChildren(...):
  ...

def bfs(...):
  ...

print(&#39;Solution: &#39; + str(bfs(state_space, initial_state, goal_state)))
```
</code></pre></div>
<p><strong>Discussion:</strong> 
- what if we want to run this code to test two other cities ? 
- for example, what if Nick was in <strong>Oradea</strong> and wanted to go to <strong>Vaslui</strong>
- how would you modify the code (without redefining inital and goal we set above) to do that? </p>
<p><strong>Task 3: Run and test your BFS Search Algorithm</strong></p>
<h2 id="preparation-for-next-week-part-ii">Preparation for next week (Part II)</h2>
<p>Reusing code is one of the most valuable skills a programmer can develop.</p>
<p>A great way to reuse the code for other search algorithms is to encapsulate it into a library or module, which you can then import and call in future Python programs.</p>
<p>In fact, any <code>.py</code> file can be used to define a Python library or module. However, to prevent code outside the functions from executing when the file is imported as a library (instead of being run as a script), we can add an extra condition check.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Node</span><span class="p">:</span>
  <span class="o">...</span>

<span class="k">def</span><span class="w"> </span><span class="nf">expandAndReturnChildren</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
  <span class="o">...</span>

<span class="k">def</span><span class="w"> </span><span class="nf">bfs</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
  <span class="o">...</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
  <span class="n">state_space</span> <span class="o">=</span> <span class="p">[</span>
  <span class="o">...</span>
  <span class="p">]</span>

  <span class="n">initial_state</span> <span class="o">=</span> <span class="s1">&#39;Arad&#39;</span>
  <span class="n">goal_state</span> <span class="o">=</span> <span class="s1">&#39;Bucharest&#39;</span>

  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Solution: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">bfs</span><span class="p">(</span><span class="n">state_space</span><span class="p">,</span> <span class="n">initial_state</span><span class="p">,</span> <span class="n">goal_state</span><span class="p">)))</span>
</code></pre></div>
<p><code>__name__</code> is a special variable in Python that evaluates to the name of the current module. This variable has the value of <code>'__main__'</code> if it's called as the main program rather than a module or library.</p>
<p>This part is essentially the <code>main</code> function in other programming languages like C++ and Java.</p>
<p>Execute the script and resolve any error.</p>
<p><strong>Prep work for Part II</strong></p>
<ol>
<li>
<p>Fully understand the code as you will have to modify the code for other problem/search algorithms in future labs.</p>
</li>
<li>
<p>How would you modify the code to run other uninformed search algorithms such as uniform-cost search, depth-first search, etc.? Which part(s) of the code do you need to modify? Think about it before you work on that in next part of this lab</p>
</li>
</ol>
<hr />
<h1 id="bonus-opportunity-machine-learning-onramp-certificate">Bonus Opportunity: Machine Learning Onramp Certificate</h1>
<p>To complement your learning in this lab and explore applied machine learning techniques, you are encouraged to complete the <strong>Machine Learning Onramp</strong> course by MathWorks.</p>
<ul>
<li><strong>Estimated Time:</strong> ~2 hours  </li>
<li><strong>Platform:</strong> Online (browser-based)  </li>
<li><strong>Outcome:</strong> Digital Certificate of Completion from MathWorks</li>
</ul>
<p><strong>Action Steps:</strong>
1. Access the course here: <a href="https://matlabacademy.mathworks.com/details/machine-learning-onramp/machinelearning">Machine Learning Onramp – MathWorks Academy</a>
2. Go through all the lessons and complete the interactive activities.
3. Download your Certificate of Completion.
4. Upload your certificate along with your Lab X submission on LMS.</p>
<p><strong>Bonus Recognition:</strong>
- Students who complete and submit this certificate will be acknowledged later in the semester.
- This is <strong>optional</strong> and will <strong>not</strong> impact your Lab X grade.</p>
<hr />












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": ["toc.integrate", "navigation.tabs"], "search": "../assets/javascripts/workers/search.f8cc74c7.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.c8b220af.min.js"></script>
      
        <script src="../javascripts/config.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>